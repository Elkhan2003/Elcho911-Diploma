import React from "react";
import { Row, Tab, Col, Nav, Container, Tabs } from "react-bootstrap";
import scss from "./Pages.module.scss";

const tabData = [
	{
		key: "first",
		title: "О системе PascalABC.NET",
		content: (
			<Tab.Pane eventKey="first">
				<h3>Система PascalABC .NET</h3>
				<p>
					PascalABC.NET – это система программирования и язык Pascal нового
					поколения для платформы Microsoft .NET. Язык PascalABC.NET содержит
					все основные элементы современных языков программирования: модули,
					классы, перегрузку операций, интерфейсы, исключения, обобщенные
					классы, сборку мусора, лямбда-выражения, а также некоторые средства
					параллельности, в том числе директивы OpenMP. Система PascalABC.NET
					включает в себя также простую интегрированную среду, ориентированную
					на эффективное обучение современному программированию.
				</p>
				<ul>
					<li>Описание языка PascalABC.NET.</li>
					<hr />
					<li>
						Преимущества PascalABC.NET для разработки программ и для обучения.
					</li>
					<hr />
					<li>Отличия PascalABC.NET от Delphi (Object Pascal).</li>
					<hr />
					<li>
						Примеры, иллюстрирующие основные особенности PascalABC.NET,
						находятся в меню "Помощь/Коротко о главном".
					</li>
					<hr />
				</ul>
				<p>
					Язык Паскаль был разработан швейцарским ученым Никлаусом Виртом в 1970
					г. как язык со строгой типизацией и интуитивно понятным синтаксисом. В
					80-е годы наиболее известной реализацией стал компилятор Turbo Pascal
					фирмы Borland, в 90-е ему на смену пришла среда программирования
					Delphi, которая стала одной из лучших сред для быстрого создания
					приложений под Windows. Delphi ввела в язык Паскаль ряд удачных
					объектно-ориентированных расширений, обновленный язык получил название
					Object Pascal. С версии Delphi 7 язык Delphi Object Pascal стал
					называться просто Delphi. Из альтернативных реализаций Object Pascal
					следует отметить многоплатформенный open source компилятор Free
					Pascal.
				</p>
				<p>
					Создание PascalABC.NET диктовалось двумя основными причинами:
					устаревание стандартного языка Pascal и систем, построенных на его
					основе (Free Pascal), а также необходимость в современной простой,
					бесплатной и мощной интегрированной среде программирования.
				</p>
				<p>
					PascalABC.NET опирается на передовую платформу программирования
					Microsoft.NET, которая обеспечивает язык PascalABC.NET огромным
					количеством стандартных библиотек и позволяет легко сочетать его с
					другими .NET-языками: C#, Visual Basic.NET, управляемый C++, Oxygene и
					др. Платформа .NET предоставляет также такие языковые средства как
					единый механизм обработки исключений, единый механизм управления
					памятью в виде сборки мусора, а также возможность свободного
					использования классов, наследования, полиморфизма и интерфейсов между
					модулями, написанными на разных .NET-языках. О том, что такое
					платформа Microsoft.NET, о ее преимуществах для программирования и для
					обучения можно прочитать здесь.
				</p>
				<p>
					Язык PascalABC.NET близок к реализации Delphi (Object Pascal). В нем
					отсутствует ряд специфических языковых конструкций Delphi, некоторые
					конструкции изменены. Кроме этого, добавлен ряд возможностей: имеется
					автоопределение типа при описании, можно описывать переменные внутри
					блока, имеются операции +=, -=, *=, /=, методы можно описывать
					непосредственно в теле класса или записи, можно пользоваться
					встроенными в стандартные типы методами и свойствами, память под
					объекты управляется сборщиком мусора и не требует явного освобождения,
					множества set могут быть созданы на основе произвольных типов, введен
					операторы foreach, переменные циклов for и foreach можно описывать
					непосредственно в заголовке цикла, имеются обобщенные классы и
					подпрограммы (generics), последовательности, кортежи, срезы,
					лямбда-выражения и др.
				</p>
				<p>
					Близким по идеологии к PascalABC.NET является язык RemObjects Oxygene
					(Object Pascal 21 века). Однако он сильно изменен в сторону .NET: нет
					глобальных описаний, все описания помещаются в класс, содержащий
					статический метод Main, отсутствует ряд стандартных подпрограмм языка
					Паскаль. Кроме того, система RemObjects Oxygene - платная и не
					содержит собственной оболочки (встраивается в Visual Studio и другие
					IDE), что практически делает невозможным ее использование в сфере
					образования.
				</p>
				<p>
					Интегрированная среда PascalABC.NET обеспечивает подсветку синтаксиса,
					подсказку по коду (подсказка по точке, подсказка параметров
					подпрограмм, всплывающая подсказка по коду), форматирование текста
					программы по запросу, переход к определению и реализации имени,
					элементы рефакторинга.
				</p>
			</Tab.Pane>
		)
	},
	{
		key: "second",
		title: "Коротко о главном",
		content: (
			<Tab.Pane eventKey="second">
				<Tabs
					defaultActiveKey="1"
					id="uncontrolled-tab-example"
					className="mb-3"
				>
					<Tab eventKey="1" title="1">
						<strong>Основное</strong>
						<ol>
							<li>
								AssignExt.pas. Данный пример иллюстрирует использование
								расширенных операторов присваивания += -= *= /= для целых и
								вещественных. Оператор /= для целых, разумеется, запрещен.
							</li>
							<hr />
							<li>
								BlockVar.pas. Переменные могут описываться внутри блока
								begin-end и инициализироваться при описании. Это крайне удобно
								для промежуточных переменных, а в PascalABC.NET в силу
								особенностей реализации еще и ускоряет доступ к переменным
								процентов на 30.
							</li>
							<hr />
							<li>
								AutoVars.pas. Если переменная инициализируется при описании, то
								ее тип можно не указывать: он определяется по типу правой части
								(автоопределение типа). Переменную - параметр цикла for можно
								описывать прямо в заголовке цикла, сочетая это с
								автоопределением типа.
							</li>
							<hr />
							<li>
								SimpleNewFeatures.pas. Пример, объединяющий возможности из
								предыдущих трех примеров.
							</li>
							<hr />
							<li>
								SimpleNewFeatures.pas. Пример, объединяющий возможности из
								предыдущих трех примеров.
							</li>
							<hr />
							<li>
								WriteFormat.pas. Стандартная процедура WriteFormat позволяет
								осуществлять форматированный вывод. Вид форматной строки
								заимствуется из .NET.
							</li>
							<hr />
							<li>
								StandardTypes.pas. В этой программе приведены все стандартные
								целые и вещественные типы. Программа выводит их размеры.
							</li>
							<hr />
							<li>
								RandomDiap.pas. К функциям генерации случайных чисел добавилась
								Random(a,b), возвращающая случайное целое в диапазоне [a,b].
								Процедуру Randomize в начале программы вызывать не надо.
							</li>
							<hr />
							<li>
								RealExtNums.pas. Действия с вещественными значениями не могут в
								.NET привести к переполнению. При некорректных операциях
								(деление на 0, переполнение или взятие логарифма отрицательного
								числа) мы получим либо значение "бесконечность", либо значение
								"NaN" (не число).
							</li>
							<hr />
							<li>
								Foreach.pas. Оператор foreach предназначен для цикла по
								контейнерам, таким как массивы, множества и контейнеры
								стандартной библиотеки (например, List "T"). Элементы контейнера
								доступны только на чтение.
							</li>
							<hr />
							<li>
								Amp.pas. Ключевые слова могут использоваться в качестве имен, в
								этом случае перед ними следует ставить значок & снятия атрибута
								ключевого слова. Кроме того, ключевые слова могут использоваться
								в качестве полей. Например, &Type или System.Type.
							</li>
							<hr />
						</ol>
					</Tab>
					<Tab eventKey="2" title="2">
						<strong>Типы</strong>
						<ol>
							<li>
								CharFunc.pas. Символы Char хранят Unicode и поэтому занимают 2
								байта. Функции Ord и Chr работают именно с Unicode. Для
								совместимости функции OrdAnsi и ChrAnsi работают в однобайтовой
								кодировке Windows.
							</li>
							<hr />
							<li>
								StringTypes.pas. Строки string занимают память переменной длины
								и проецируются на .NET-тип System.String. Однако, в отличие от
								NET-строк они изменяемы и индексируются с 1. Для работы со
								строками фиксированной длины следует использовать тип string[n]
								или shortstring=string[255]. В частности, типизированные файлы
								допустимы только для коротких строк.
							</li>
							<hr />
							<li>
								StringMethods.pas. Строки string имеют ряд методов как
								.NET-классы. В этих методах предполагается, что строки
								индексируются с нуля.
							</li>
							<hr />
							<li>
								StringInteger.pas. Все типы - классы. Простые типы тоже. Поэтому
								преобразование строки в целое и вещественное проще выполнять с
								помощью статических методов Parse соответствующего класса
								(например, integer.Parse(s)). Преобразование целого или
								вещественного в строку удобнее выполнять с помощью экземплярного
								метода ToString (например, r.ToString).
							</li>
							<hr />
							<li>
								Enum.pas. Перечислимый тип позволяет обращаться к его константам
								не только непосредственно, но и используя запись вида
								ИмяТипа.ИмяКонстанты. Нелишне отметить, что все перечислимые
								типы - производные от System.Enum.
							</li>
							<hr />
							<li>
								Sets.pas. Множества могут иметь произвольный базовый тип. Внутри
								множество хранится как хеш-таблица, однако при выводе множества
								в процедуре write его элементы упорядочиваются.
							</li>
							<hr />
							<li>
								DynArray.pas. Динамические массивы array of T представляют собой
								ссылки. Память под них должна выделяться либо вызовом
								стандартной процедуры SetLength, либо использованием
								инициализатора вида new T[n]. Процедура SetLength сохраняет
								старое содержимое массива. Динамические массивы являются
								классом, производным от класса System.Array, имеющего достаточно
								богатый интерфейс. Следует упомянуть прежде всего статические
								методы &Array.Sort и &Array.Resize.
							</li>
							<hr />
							<li>
								InitRecords.pas. В записях допустимы инициализаторы полей. Поля
								записи инициализируются при создании переменной-записи.
							</li>
							<hr />
							<li>
								UntypedFile.pas. Бестиповые файлы file изменены по сравнению с
								Delphi. Отсутствуют процедуры BlockRead и BlockWrite, но в
								бестиповой файл можно непосредственно записывать данные разных
								типов. Лишь бы считывание производилось в том же порядке.
							</li>
							<hr />
							<li>
								PointerToRef.pas. Имеют место некоторые ограничения для
								указателей на управляемую память. Так, указатель не может прямо
								или косвенно указывать на объект класса, память для которого
								выделена вызовом конструктора.
							</li>
							<hr />
							<li>
								Pointers.pas и References.pas. Указатели утрачивают свои
								позиции. Вместо них мы рекомендуем активно использовать ссылки.
							</li>
							<hr />
							<li>
								StructTypeEquiv.pas. В отличие от Delphi, для некоторых типов
								имеет место структурная, а не именная эквивалентность типов.
								Так, структурная эквивалентность имеет место для динамических
								массивов, указателей, множеств и процедурных типов.
							</li>
							<hr />
						</ol>
					</Tab>
					<Tab eventKey="3" title="3">
						<strong>Подпрограммы</strong>
						<ol>
							<li>
								FuncParams.pas. Подпрограммы с переменным числом параметров
								делаются легко добавлением ключевого слова params перед
								параметром - динамическим массивом. Такой параметр должен быть
								последним в списке.
							</li>
							<hr />
							<li>
								Overload.pas. Перегрузка имен подпрограмм осуществляется без
								ключевого слова overload.
							</li>
							<hr />
							<li>
								ProcVars.pas. Процедурные переменные могут "накапливать"
								действия при помощи оператора +=. Эти действия можно отключать
								при помощи оператора -=. Процедурные переменные могут
								инициализироваться не только обычными подпрограммами, но и
								статическими и экземплярными методами класса.
							</li>
							<hr />
							<li>
								SwapT.pas. Обобщенные подпрограммы имеют простой синтаксис и
								используются сразу наряду с обычными: procedure Swap"T"(var x,y:
								T);
							</li>
							<hr />
						</ol>
					</Tab>
					<Tab eventKey="4" title="4">
						<strong>Модули</strong>
						<ol>
							<li>
								SystemUnitTest.pas. Системный модуль имеет название PABCSystem,
								а не System, как в Delphi, и подключается неявно первым в списке
								uses. Причина такого именования состоит в том, что важнейшее
								пространство имен .NET имеет имя System. Системный модуль
								объединяет многие подпрограммы модулей System, Math и Utils
								языка Delphi. Данная программа иллюстрирует пересечение имен во
								модуле PABCSystem и пространстве имен System.
							</li>
							<hr />
							<li>
								MainProgram.pas и MyUnit.pas. Модуль может иметь упрощенный
								синтаксис (без деления на раздел интерфейса и раздел
								реализации), что удобно для начального обучения. В этом случае
								все описанные имена попадают в раздел интерфейса модуля.
							</li>
							<hr />
							<li>
								SystemUnitTest.pas. Для использования пространств имен .NET
								применяется тот же синтаксис, что и при подключении модулей:
								пространства имен .NET указываются в списке uses. Порядок поиска
								имен такой же, как и в Delphi - справа налево в списке uses,
								модуль PABCSystem просматривается последним.
							</li>
							<hr />
							<li>
								Main.pas и MyDll.pas. В PascalABC.NET легко создать и
								использовать dll. Библиотека dll по-существу представляет собой
								модуль, где вместо ключевого слова unit используется слово
								library. Для подключения dll к другой программе используется
								директива компилятора reference.
							</li>
							<hr />
							<li>
								CallCS.pas. PascalABC.NET - полноценный .NET-язык, легко
								совмещаемый с другими .NET-языками. В данном примере
								показывается, как в программе на PascalABC.NET вызвать функцию
								из dll, созданной на C#.
							</li>
							<hr />
							<li>
								CallNative.pas. PascalABC.NET позволяет легко вызывать функции
								из обычных dll.
							</li>
							<hr />
						</ol>
					</Tab>
					<Tab eventKey="5" title="5">
						<strong>Стандартные графические библиотеки</strong>
						<ol>
							<li>
								GraphABCTest.pas. Графическая библиотека GraphABC заточена под
								легкое обучение программированию графики. Она скрывает
								большинство сложностей программирования графики: сама
								осуществляет перерисовку графического окна в нужный момент и
								заботится о синхронизации рисования в нескольких обработчиках.
								Кроме того, графические примитивы - процедурные, а значит, не
								надо создавать многочисленные классы, как в NET. И еще можно
								писать графические команды сразу после begin основной программы,
								то есть использовать графику в несобытийных приложениях.
							</li>
							<hr />
							<li>
								MouseEvents.pas. Для графических приложений можно использовать
								простейшие события мыши и клавиатуры, реализованные как
								глобальные процедурные переменные.
							</li>
							<hr />
							<li>
								ABC.pas. Библиотека векторных графических объектов ABCObjects
								используется нами для раннего обучения школьников основам
								объектно-ориентированного программирования. Однако, ее вполне
								можно использовать для написания несложных графических
								обучающе-игровых приложений.
							</li>
							<hr />
						</ol>
					</Tab>
					<Tab eventKey="6" title="6">
						<strong>Классы</strong>
						<ol>
							<li>
								AllFromObject.pas. Все классы - наследники Object, все типы -
								классы. У каждой переменной можно узнать тип, вызвав метод
								GetType. Операция typeof для типа возвращает System.Type.
							</li>
							<hr />
							<li>
								WriteRecord.pas. Переопределив метод ToString в классе или
								записи, мы получаем возможность выводить их значения в процедуре
								writeln
							</li>
							<hr />
							<li>
								ClassConstructor.pas. Для статических методов и полей
								используется ключевое слово class. Статические конструкторы
								используются для нетривиальной инициализации статических полей.
							</li>
							<hr />
							<li>
								PersonInternal.pas. Новый синтаксис конструкторов использует
								ключевое слово new и является предпочтительным. По этой причине
								все конструкторы, определенные в старом стиле, должны иметь имя
								Create. Описание методов может производиться непосредственно
								внутри классов и записей (как в C++, C# и Java)
							</li>
							<hr />
							<li>
								Records.pas. Методы и конструкторы в записях можно использовать
								так же, как и в классах. От записей нельзя наследовать и записи
								нельзя наследовать.
							</li>
							<hr />
							<li>
								Boxing.pas. При присваивании размерного типа объекту типа Object
								происходит упаковка. Для распаковки следует использовать явное
								приведение типа.
							</li>
							<hr />
							<li>
								GarbageCollection.pas. Деструкторы отсутствуют. Автоматическая
								сборка мусора для возврата памяти, распределенной объектной
								переменной, требует, чтобы на эту память никто более не
								ссылался, прямо или косвенно. Поэтому для освобождения памяти
								обычно достаточно присвоить объектной переменной nil.
							</li>
							<hr />
							<li>
								OperatorOverloading.pas. Как и в C++ и C#, в PascalABC.NET можно
								перегружать знаки операций для записей и классов.
							</li>
							<hr />
							<li>
								Interf.pas. Интерфейсы семантически совпадают с интерфейсами в
								C# и Java. Сложная реализация интерфейсов Delphi на основе COM
								отвергнута.
							</li>
							<hr />
							<li>
								Stack.pas. Обобщенные классы (generics) позволяют создавать
								классы, параметризованные одним или несколькими типами.
							</li>
							<hr />
							<li>
								Where.pas. Можно задавать ограничения на типы параметров
								обобщенных классов. Ограничения бывают трех сортов: наличие у
								типа-параметра конструктора по умолчанию, наследование его от
								конкретного класса или реализация интерфейса.
							</li>
							<hr />
						</ol>
					</Tab>
					<Tab eventKey="7" title="7">
						<strong>Стандартная библиотека .NET</strong>
						<ol>
							<li>
								DateTime.pas. Данный пример иллюстрирует применение класса
								DateTime из стандартной библиотеки .NET.
							</li>
							<hr />
							<li>
								LinkedList.pas. Данный пример иллюстрирует использование
								контейнерных классов из стандартной библиотеки .NET.
							</li>
							<hr />
							<li>
								WinFormWithButton.pas. Данный пример иллюстрирует создание
								оконного приложения.
							</li>
							<hr />
						</ol>
					</Tab>
				</Tabs>
			</Tab.Pane>
		)
	},
	{
		key: "three",
		title: "Что такое .NET",
		content: (
			<Tab.Pane eventKey="three">
				<Tabs
					defaultActiveKey="1"
					id="uncontrolled-tab-example"
					className="mb-3"
				>
					<Tab eventKey="1" title="1">
						<h3>Что такое .NET</h3>
						<div>
							<p>
								Платформа Microsoft .NET - это комплекс программ,
								устанавливаемый поверх операционной системы и обеспечивающий
								выполнение программ, написанных специально для .NET.
								.NET-программы компактны, пользуются единым набором типов данных
								и библиотек. Компания Microsoft активно развивает платформу
								.NET, выпуская новые версии с расширенными возможностями. На
								момент начала 2019 г. последней версией является .NET 4.7.1.
							</p>
							<p>
								В результате компиляции .NET-программы генерируется не машинный
								код, а так называемый байт-код, содержащий команды виртуальной
								машины (в .NET он называется IL-кодом от англ. Intermediate
								Language - промежуточный язык). Команды байт-кода не зависят от
								процессора и используемой операционной системы. При запуске
								программа, содержащая IL-код, подается на вход виртуальной
								машины, которая и производит выполнение программы. Часть
								виртуальной машины, называемая JIT-компилятором (Just In Time -
								непосредственно в данный момент), сразу после запуска
								.NET-программы переводит ее промежуточный код в машинный
								(проводя при этом его оптимизацию), после чего запускает
								программу на исполнение. Если быть точными, то промежуточный код
								переводится в машинный частями по мере выполнения программы.
							</p>
							<p>
								Такой способ двойной компиляции сложнее обычного, но имеет ряд
								преимуществ. Во-первых, JIT-компилятор может определить тип
								процессора, установленного на данном компьютере, поэтому
								генерирует максимально эффективный машинный код. Тесты
								показывают, что за счет этого некоторые программы выполняются
								даже быстрее обычных. Во-вторых, IL-код - гораздо более
								высокоуровневый, чем машинный, и содержит ряд
								объектно-ориентированных команд. В их числе - команда newobj
								вызова конструктора объекта, команда callvirt вызова
								виртуального метода объекта и команда throw генерации
								исключения.
							</p>
							<p>
								Программа или библиотека для .NET называется сборкой и имеет
								традиционное расширение - exe или dll. Поскольку в сборках
								содержится IL-код, они значительно компактнее обычных программ и
								библиотек. Так, приложение с главным окном, меню и элементами
								управления занимает на диске всего несколько десятков килобайт.
							</p>
							<p>
								Наиболее "чистым" .NET-языком является C#: он создавался
								специально для платформы .NET и включает практически все ее
								возможности. .NET-языки легко взаимодействуют друг с другом не
								только за счет высокоуровневого промежуточного кода, но и за
								счет общей системы типов (CTS - Common Type System - общая
								система типов). Все стандартные типы (строковые, символьные,
								числовые и логический) имеют одинаковое представление в памяти
								во всех .NET-языках. Это позволяет, например, создать библиотеку
								dll на C#, поместить в нее описание класса, а затем
								воспользоваться этой библиотекой из программы на PascalABC.NET,
								сконструировав объект данного класса. Можно также разработать
								библиотеку на PascalABC.NET, а потом подключить ее к проекту на
								Visual Basic.NET. Отметим, что традиционные библиотеки dll не
								позволяют хранить классы, доступные извне, и обладают рядом
								других ограничений.
							</p>
							<p>
								Важнейшими средствами, предоставляемыми платформой .NET,
								являются единый способ обработки ошибок - генерация и перехват
								исключений, - а также автоматическое управление освобождением
								динамической памяти, называемое сборкой мусора. Последнее, в
								частности, означает, что отсутствует необходимость в
								деструкторах классов.
							</p>
							<p>
								Имеются программы, которые могут восстанавливать текст программы
								по IL-коду (например, программа ILSpy).
							</p>
							<p>
								Помимо JIT-компилятора, важной частью платформы .NET является
								набор стандартных библиотек (FCL - Foundation Class Library -
								общая библиотека классов). Среди них - библиотеки работы с
								графикой, сетью, базами данных, XML, контейнерами, потоками,
								содержащие тысячи классов. Каждый .NET-язык может пользоваться
								всеми возможностями этих библиотек.
							</p>
							<p>
								Имеется открытая кроссплатформенная реализация среды
								Microsoft.NET -{" "}
								<a href="https://www.mono-project.com/" target="_ blank">
									среда Mono
								</a>
								, позволяющая в частности разрабатывать и запускать
								.NET-программы под Linux.
							</p>
							<p>Кратко отметим достоинства и недостатки платформы .NET.</p>
						</div>
					</Tab>
					<Tab eventKey="2" title="2">
						<strong>Достоинства платформы .NET</strong>
						<ol>
							<li>
								Платформа .NET поддерживает множество .NET-языков. В их числе
								C#, Visual Basic.NET, F#, управляемый C++, Delphi Prism, Oberon,
								Zonnon, Iron Python, Iron Ruby, PascalABC.NET.
							</li>
							<hr />
							<li>
								Любой .NET-язык содержит самые современные языковые возможности:
								классы, свойства, полиморфизм, исключения, перегрузка операций,
								легкое создание библиотек.
							</li>
							<hr />
							<li>
								.NET-языки легко сочетаются друг с другом, похожи друг на друга
								по синтаксическим конструкциям и системе типов.
							</li>
							<hr />
							<li>Имеется обширная библиотека стандартных классов FCL.</li>
							<hr />
							<li>.NET-приложения компактны.</li>
							<hr />
							<li>
								Платформа .NET активно развивается фирмой Microsoft, добавляются
								как новые языковые возможности, так и новые библиотеки.
							</li>
							<hr />
							<li>
								Компилятор .NET-языка создать значительно проще, чем компилятор
								обычного языка.
							</li>
							<hr />
						</ol>
					</Tab>
					<Tab eventKey="3" title="3">
						<strong>Недостатки платформы .NET</strong>
						<ol>
							<li>
								Запуск .NET-приложения выполняется в несколько раз медленнее
								запуска обычного приложения, поскольку требует загрузки в
								оперативную память компонентов виртуальной машины и внешних
								библиотек.
							</li>
							<hr />
							<li>
								.NET-код в некоторых ситуациях работает медленнее обычного
								(однако, в большинстве задач это отставание незначительно, а в
								некоторых - приложения .NET могут опережать обычные программы).
							</li>
							<hr />
							<li>
								Сборщик мусора начинает работу в момент исчерпания динамической
								памяти, его работа занимает несколько миллисекунд. Для
								приложений реального времени это непозволительно.
							</li>
							<hr />
							<li>
								Запуск .NET-приложения обязательно требует установки на
								компьютере платформы .NET. Без нее приложение работать не будет
								(Отметим, что в Windows Vista и в Windows 7 платформа .NET
								встроена).
							</li>
							<hr />
						</ol>
						<p>
							Отметим, что достоинства платформы .NET многократно перекрывают ее
							недостатки.
						</p>
					</Tab>
				</Tabs>
			</Tab.Pane>
		)
	},
	{
		key: "four",
		title: "Преимущества PascalABC.NET",
		content: (
			<Tab.Pane eventKey="four">
				<Tabs
					defaultActiveKey="1"
					id="uncontrolled-tab-example"
					className="mb-3"
				>
					<Tab eventKey="1" title="1">
						<h3>Преимущества PascalABC.NET</h3>
						<strong>Современный язык программирования Object Pascal</strong>
						<div>
							<p>
								Язык PascalABC.NET включает в себя практически весь стандартный
								язык Паскаль, а также большинство языковых расширений языка
								Delphi. Однако, этих средств недостаточно для современного
								программирования. Именно поэтому PascalABC.NET расширен рядом
								конструкций, а его стандартный модуль - рядом подпрограмм, типов
								и классов, что позволяет создавать легко читающиеся приложения
								средней сложности.
							</p>
							<p>
								Кроме этого, язык PascalABC.NET использует большинство средств,
								предоставляемых платформой .NET: единая система типов, классы,
								интерфейсы, исключения, делегаты, перегрузка операций,
								обобщенные типы (generics), методы расширения, лямбда-выражения.
							</p>
							<p>
								Стандартный модуль PABCSystem, автоматически подключаемый к
								любой программе, содержит огромное количество стандартных типов
								и подпрограмм, позволяющих писать ясные и компактные программы.
							</p>
							<p>
								В распоряжении PascalABC.NET находятся все средства
								.NET-библиотек классов, постоянно расширяющихся самыми
								современными возможностями. Это позволяет легко писать на
								PascalABC.NET приложения для работы с сетью, Web,
								XML-документами, использовать регулярные выражения и многое
								другое.
							</p>
							<p>
								Язык PascalABC.NET позволяет программировать в классическом
								процедурном стиле, в объектно-ориентированном стиле и содержит
								множество элементов для программирования в функциональном стиле.
								Выбор стиля или комбинации этих стилей - дело вкуса
								программиста, а при использовании в обучении - методический
								подход преподавателя.
							</p>
							<p>
								Сочетание богатых и современных языковых средств, возможностей
								выбора разных траекторий обучения позволяет рекомендовать
								PascalABC.NET с одной стороны как язык для обучения
								программированию (от школьников до студентов младших и средних
								курсов), с другой - как язык для создания проектов и библиотек
								средней сложности.
							</p>
						</div>
					</Tab>
					<Tab eventKey="2" title="2">
						<strong>Простая и мощная среда разработки</strong>
						<div>
							<p>
								Интегрированная среда разработки PascalABC.NET ориентирована на
								создание проектов малой и средней сложности. Она достаточно
								легковесна и в то же время обеспечивает разработчика всеми
								необходимыми средствами, такими как встроенный отладчик,
								средства Intellisense (подсказка по точке, подсказка по
								параметрам, всплывающая подсказка по имени), переход к
								определению и реализации подпрограммы, шаблоны кода,
								автоформатирование кода.
							</p>
							<p>
								В среду PascalABC.NET встроен также дизайнер форм, позволяющий
								создавать полноценные оконные приложения в стиле RAD (Rapid
								Application Development - быстрое создание приложений).
							</p>
							<p>
								В отличие от многих профессиональных сред, среда разработки
								PascalABC.NET не имеет громоздкого интерфейса и не создает
								множество дополнительных вспомогательных файлов на диске при
								компиляции программы. Для небольших программ это позволяет
								соблюсти принцип "Одна программа - один файл на диске".
							</p>
							<p>
								В среде PascalABC.NET большое внимание уделено связи запущенной
								программы с оболочкой: консольная программа, запущенная из-под
								оболочки, осуществляет ввод-вывод в специальное окно, встроенное
								в оболочку. Можно также запустить несколько программ
								одновременно - все они будут контролироваться оболочкой.
							</p>
							<p>
								Интегрированная среда PascalABC.NET позволяет переключать в
								настройках русский и английский язык, при этом локализованы не
								только элементы интерфейса, но и сообщения об ошибках.
							</p>
							<p>
								Кроме этого, внутренние представления PascalABC.NET позволяют
								создавать компиляторы других языков программирования и
								встраивать их в среду разработки с помощью специальных плагинов.
							</p>
						</div>
					</Tab>
					<Tab eventKey="3" title="3">
						<strong>Специализированные модули для обучения</strong>
						<div>
							<p>
								Платформа Microsoft.NET обеспечивает PascalABC.NET стандартной
								библиотекой, состоящей из огромного количества класссов для
								решения практически любых задач: от алгоритмических до
								прикладных. Именно поэтому в PascalABC.NET отсутствует
								необходимость в разработке большого числа собственных модулей.
							</p>
							<p>
								Собственные модули, которые имеются в PascalABC.NET,
								ориентированы именно на начальное обучение программированию.
							</p>
							<p>
								Для обучения программированию школьников реализованы модули
								классических школьных исполнителей Робот и Чертежник, содержащие
								около двухсот автоматически проверяемых заданий на основные
								конструкции языка программирования.
							</p>
							<p>
								Кроме этого, среда PascalABC.NET содержит модуль электронного
								задачника Programming Taskbook (автор Абрамян М.Э.), позволяющий
								осуществлять автоматическую постановку и проверку заданий.
								Имеются также модули для преподавателя, позволяющие создавать
								задания для исполнителей Робот, Чертежник и электронного
								задачника.
							</p>
							<p>
								Модуль растровой графики GraphWPF и модуль векторных графических
								объектов WPFObjects и модуль трёхмерной графики Graph3D могут
								быть использованы для создания простейших графических. а также
								интерактивных анимационных приложений, управляемых событиями.
							</p>
							<p>
								Следует также отметить "студенческие" модули: модуль Collections
								упрощенных коллекций, модуль Arrays для простейших операций с
								динамическими массивами и модуль Forms для ручного создания
								простых приложений с оконным пользовательским интерфейсом.
							</p>
						</div>
					</Tab>
				</Tabs>
				<div></div>
			</Tab.Pane>
		)
	},
	{
		key: "five",
		title: "Отличия языка PascalABC.NET от Delphi",
		content: (
			<Tab.Pane eventKey="five">
				<Tabs
					defaultActiveKey="1"
					id="uncontrolled-tab-example"
					className="mb-3"
				>
					<Tab eventKey="1" title="1">
						<h3>Отличия языка PascalABC.NET от Delphi</h3>
						<strong>Добавлено</strong>
						<ol>
							<li>
								Операции += -= для событий .NET и для процедурных переменных.
							</li>
							<hr />
							<li>
								Операции += -= *= для целых и += -= *= /= для вещественных.
							</li>
							<hr />
							<li>Операция += для строк.</li>
							<hr />
							<li>Подпрограммы с переменным числом параметров.</li>
							<hr />
							<li>
								Операция new для вызова конструктора (ident := new
								type_name(params);).
							</li>
							<hr />
							<li>Операция new для создания динамического массива.</li>
							<hr />
							<li>Операция typeof .</li>
							<hr />
							<li>
								Использование uses для подключения пространств имен .NET
								(реализовано в Delphi Prism).
							</li>
							<hr />
							<li>
								Вид доступа internal (наряду с public, private, protected).
							</li>
							<hr />
							<li>Инициализация переменных: var a: integer := 1;</li>
							<hr />
							<li>Инициализация переменных: var a := 1;</li>
							<hr />
							<li>Объявление локальных переменных в блоке.</li>
							<hr />
							<li>
								Объявление параметра цикла в заголовке цикла: for var i := 1 to
								10 do, foreach var x in a do.
							</li>
							<hr />
							<li>Оператор lock, обеспечивающий синхронизацию потоков.</li>
							<hr />
							<li>Методы в записях.</li>
							<hr />
							<li>Инициализаторы полей в классах и записях.</li>
							<hr />
							<li>Обобщенные классы (generics).</li>
							<hr />
							<li>
								Реализованы типизированные файлы (в отличие от Delphi Prism, где
								они убраны).
							</li>
							<hr />
							<li>Упрощенный синтаксис модулей.</li>
							<hr />
							<li>Описание методов внутри интерфейса класса или записи.</li>
							<hr />
							<li>Реализация записью интерфейса.</li>
							<hr />
							<li>Методы расширения.</li>
							<hr />
							<li>Лямбда-выражения.</li>
							<hr />
						</ol>
					</Tab>
					<Tab eventKey="2" title="2">
						<strong>Изменено</strong>
						<ol>
							<li>Только сокращенное вычисление логических выражений.</li>
							<hr />
							<li>Другой синтаксис foreach.</li>
							<hr />
							<li>Интерфейсы interface в стиле .NET.</li>
							<hr />
							<li>Другой синтаксис перегрузки операций.</li>
							<hr />
							<li>
								Статические методы классов вместо классовых методов. Отсутствие
								типа TClass.
							</li>
							<hr />
							<li>
								Деструкторы оставлены лишь для совместимости и не выполняют
								никаких действий.
							</li>
							<hr />
							<li>Тип object - синоним System.Object.</li>
							<hr />
							<li>Тип exception - синоним System.Exception.</li>
							<hr />
							<li>
								Индексация string с 1, директива переключения на индексацию с 0.
							</li>
							<hr />
							<li>Процедура Write выводит любые типы.</li>
							<hr />
							<li>
								Структурная эквивалентность типов для процедурных переменных,
								динамических массивов, типизированных указателей и множеств (в
								Delphi Object Pascal - именная эквивалентность типов за
								исключением открытых массивов).
							</li>
							<hr />
							<li>Множества на базе произвольных типов (set of string).</li>
							<hr />
							<li>Запрет использования указателей на управляемую память.</li>
							<hr />
							<li>
								Процедурные переменные (делегаты) вместо procedure of object.
							</li>
							<hr />
							<li>
								С бестиповыми файлами file можно работать с помощью процедур
								Read, Write.
							</li>
							<hr />
							<li>
								Массивы массивов отличаются по типу от двумерных массивов (в
								частности, записи a[i][j] и a[i,j] неэквивалентны).
							</li>
							<hr />
							<li>Перегрузка выполняется без ключевого слова overload.</li>
							<hr />
							<li>Все конструкторы имеют имя Create.</li>
							<hr />
							<li>
								Автоматическое управление памятью с помощью сборщика мусора (за
								исключением указателей на неуправляемую память).
							</li>
							<hr />
						</ol>
					</Tab>
					<Tab eventKey="3" title="3">
						<strong>Отсутствует</strong>
						<ol>
							<li>
								Ключевые слова и директивы packed threadvar inline asm exports
								unsafe resourcestring dispinterface in out absolute dynamic
								local platform requires export message resident assembler
								safecall automated far near stdcall cdecl published stored
								contains implements varargs default deprecated package register
								dispid pascal writeonly и связанные с ними возможности.
							</li>
							<hr />
							<li>Приведение типов для переменных: Char(b) := 'd'.</li>
							<hr />
							<li>
								Возможность присвоить адрес подпрограммы указателю pointer.
							</li>
							<hr />
							<li>Записи с вариантами.</li>
							<hr />
							<li>Строки PChar.</li>
							<hr />
							<li>
								Возможность использовать операцию @ для процедурных переменных.
							</li>
							<hr />
							<li>Вариантные типы.</li>
							<hr />
							<li>Бестиповые параметры (var a; const b).</li>
							<hr />
							<li>Открытые массивы (не путать с динамическими!).</li>
							<hr />
							<li>Методы, связанные с сообщениями (message).</li>
							<hr />
							<li>Вложенные определения классов.</li>
							<hr />
						</ol>
					</Tab>
				</Tabs>
			</Tab.Pane>
		)
	}
];

export const About = () => {
	return (
		<div style={{ marginTop: "70px", padding: "0 0" }} className={scss.content}>
			<Container>
				<Tab.Container id="left-tabs-example" defaultActiveKey="first">
					<Row>
						<Col sm={3}>
							<Nav variant="pills" className="flex-column">
								{tabData.map(({ key, title }) => (
									<Nav.Item key={key} className={scss.about__tabs}>
										<Nav.Link eventKey={key}>{title}</Nav.Link>
									</Nav.Item>
								))}
							</Nav>
						</Col>
						<Col sm={9}>
							<Tab.Content>
								{tabData.map(({ key, content }) => (
									<React.Fragment key={key}>{content}</React.Fragment>
								))}
							</Tab.Content>
						</Col>
					</Row>
				</Tab.Container>
			</Container>
		</div>
	);
};
